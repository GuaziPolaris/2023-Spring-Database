# 11 NoSQL

NoSQL没有规范的定义
“开源分布式的非关系型数据库”
各种NoSQL数据库的共同特性是

1. 不使用关系模型

2. 在集群中运行良好
   
   1. 关系型数据库使用ACID事务来保持整个数据库的一致性，而这种方式本身与集群环境相冲突
   
   2. NoSQL数据库为处理并发及分布问题提供了众多选项。

开源

适用于21世纪的互联网公司

无模式

1. 不用事先修改结构定义，即可自由添加字段了

2. 这在处理不规则数据和自定义字段时非常有用

为什么需要NoSQL？  
- 关系模型把数据组织成 “关系”和“元组”，元组不能包含“嵌套记录”或“列表”等任何结构。而内存中的数据结构则无此限制，它可以使用的数据组织形式比“关系”更丰富。关系模型和内存中的数据结构之间存在差异，这种现象通常称为“阻抗失谐”，需使用对象-关系映射框架通过映射模式进行转换，存在查询性能问题  
- 如果将数据库视为“应用程序数据库”，其内容只能由一个应用程序的代码库直接访问，交互工作转交由应用程序接口来完成，由于内部数据库与外部通信服务之间已经解耦，所以外界并不关心数据如何存储，这样就可以选用非关系型数据库了  
- 关系型数据库与集群不协调。关系型数据库也可以将数据划分为几个集合，实现“分片”和“复制”，但查询、参照完整性、 事务、一致性控制等操作难以跨分片的方式执行，而NoSQL在集群中运行良好，为处理并发及分布问题提供了众多选项

## 键值数据库

键值数据库(key-value store)是一张简单的哈希表(hash table)，主要用在所有数据库访问均通过主键(primary key)来操作的情况下。
可把此表想象成传统的“关系” 该关系有两列：ID与NAME
ID列代表关键字，NAME列存放值。NAME列仅能存放String型的数据。
应用程序可提供ID及VALUE值，并将这一键值对持久化
假如ID已存在，就用新值覆盖当前值，否则就新建一条数据。

![](C:\Users\Polaris\AppData\Roaming\marktext\images\2023-06-12-19-29-33-image.png)

文档数据库中，放在同一“集合”内的各文档的“数据模式”(the schema of the data)可以不同

1. 关系型数据库中，表格中每行数据的模式都要相同。

文档中可以嵌套数组等基本数据类型，也可以将“子文档”(child document) 以“子对象”(subobject) 的形式嵌入主文档。
由于没有“数据模式”约定，文档数据库的文档中无需空属性，若其中不存在某属性，就假定该属性值未设定或与此文档无关。向文档中新增属性时，既无需预先定义，也不用修改已有文档内容。

1. 关系型数据库中，需要定义表中的每一列，而且若某条记录中的某列没有数据，则要将其留空(empty) 或设为null。

#### 一致性

只有针对单个键的操作才具备“一致性”，因为这种操作只可能是“获取”、“设置”或“删除”。

1. 由于数据库无法侦测数值改动， “乐观写入”(optimistic write)功能的实现成本太高。

分布式键值数据库，用“最终一致性模型” 实现“一致性”。

1. 两种解决“更新冲突”的办法:
   
   1. 采纳新写入的数据而拒绝旧数据
   
   2. 将两者(或存在冲突的所有数据)返回给客户端，令其解决冲突

在创建“存储区”时设置与一致性有关的选项。

1. 若想提高数据一致性, 可以规定：执行完写入操作后，只有当存放此数据的全部节点一致将其更新，才认定该操作生效。
   
   1. 显然降低了集群的写入效率

2. 若想提高写入冲突或读取冲突的解决速度，可在创建“存储区”时设置为数据库接纳最新的写入操作，而不再创立“旁系记录”(sibling) 。

#### 事务

不同类型的键值数据库，其“事务”规范也不同，实现“事务”的方式各异。一般说来，无法保证写入操作的“一致性"。
Riak在调用写入数据的API时，它使用W值与复制因子来实现“仲裁”。

1. 假设某个集群的复制因子是5，而W值为3。

2. 在写入数据时，必须有至少3个节点汇报其写入操作已顺利完成，数据库才会认为此操作执行完毕。

3. 由于N等于5而W是3，所以集群在两个节点(N-W=2) 故障时仍可执行写入操作，不过此时我们无法从那些发生故障的节点中读取某些数据。

#### 键值设计

使用键值数据库时，通过某种算法生成键

使用用户信息(例如ID、电子邮件地址等)、时间戳等值，生成键

l键值数据库非常适合保存会话(用会话ID作为键)、购物车数据、用户配置等信息

#### 数据结构

键值数据库并不关心键值对里的值。它可以是二进制块、文本、JSON、XML等。

可在HTTP请求中用Content-Type指定数据类型

1. 实质上是由应用判定其内容

#### 可扩展性

很多键值数据库都可用“分片”技术扩展。采用此技术后，键的名字就决定了负责存储该键的节点。

1. 假设按照键名的首字母“分片”。如果键名是f4b19d79587d，那么由于其首字母为f,所以存放它的节点就与存放ad9c7a396542这个键的节点不同。

2. 当集群中的节点数变多时，这种“分片”设定可提高效率。

“分片”也会引发某些问题。假如存放首字母为f的键所用的那个节点坏了，那么其上的数据将无法访问，而且也不能再写入其他键名首字母为f的新数据了。

可以控制“CAP定理” 中的参数: N (存放键值对的副本节点数)、R (顺利完成读取操作所需的最小节点数)和W (顺利完成写入操作所需的最小节点数)。

1. 假设集群有5个节点。将N设为3，意思就是所有数据都至少要复制到3个节点中，将R设为2，意思是GET请求要有两个节点应答，才能成功，将W设为2,意思是PUT请求必须写入两个节点，才算执行完毕。

可以利用这些设置来微调读取及写入操作所能容忍的故障节点数。应该按照应用的需要来改变这些值，以提升数据库的“可读能力”(read availability) 及“可写能力”(write availability)。通常应该根据“一致性”需求来确定W值。

创建“存储区”时可设定上述各参数的默认值。

### 适用案例

#### 事件记录

在企业级解决方案中，许多不同的应用程序都需要记录事件。应用程序对事件记录各有需求。

文档数据库可以把所有这些不同类型的事件都存起来，并作为事件存储的中心数据库（central data store）使用。

如果事件捕获的数据类型一直在变，那么就更应该用文档数据库了。

可以按照触发事件的应用程序名分片，也可以按照 order_processed 或 customer_logged 等事件类型分片。

#### 内容管理系统及博客平台

由于文档数据库没有预设模式（predefined schema），而且通常支持 JSON 文档，所以它们很适合用在内容管理系统（content management system）及网站发布程序上，也可以用来管理用户评论、用户注册、用户配置和面向 Web 文档（web-facing document）。

#### 网站分析与实时分析

文档数据库可存储实时分析数据。由于可以只更新部分文档内容，所以用它来存储页面浏览量（page view）或独立访客数（unique visitor）会非常方便，而且无需改变模式即可新增度量标准。

#### 电子商务应用程序

电子商务类应用程序通常需要较为灵活的模式，以存储产品和订单。同时，它们也需要在不做高成本数据库重构及数据迁移的前提下进化其数据模型。

### 不适用场合

#### 包含多项操作的复杂事务

文档数据库也许不适合执行跨文档的原子操作（atomic cross-document operation），虽然像 RavenDB 等文档数据库其实也支持此类操作。

#### 查询持续变化的聚合结构

灵活的模式意味着数据库对模式不施加任何限制。数据以应用程序实体（application entity）的形式存储。

如果要即时查询这些持续改变的实体，那么所用的查询命令也得不停变化（用关系型数据库的术语讲，就是：用 JOIN 语句将数据表按查询标准连接起来时，待连接的表一直在变）。

由于数据保存在聚合中，所以假如聚合的设计持续变动，那么就需要以最低级别的粒度（lowest level of granularity）来保存聚合了，这实际上就等于要统一数据格式了。在这种情况下，文档数据库也许不合适。

## 文档数据库

“文档”( document)是文档数据库中的主要概念。

其格式可以是XML、JSON、BSON等。

文档具备自述性(self-describing)，呈现分层的树状数据结构(hierarchical tree data
structure)，可以包含映射表、集合和标量值。

文档彼此相似，但不必完全相同。文档数据库所存放的文档，就相当于键值数据库所存放的“值”。

文档数据库可视为其值可查的键值数据库。

![](C:\Users\Polaris\AppData\Roaming\marktext\images\2023-06-12-20-11-08-image.png)

文档数据库中，放在同一“集合”内的各文档的“数据模式”(the schema of the data)可以不同

1. 关系型数据库中，表格中每行数据的模式都要相同。

文档中可以嵌套数组等基本数据类型，也可以将“子文档”(child document) 以“子对象”(subobject) 的形式嵌入主文档。

由于没有“数据模式”约定，文档数据库的文档中无需空属性，若其中不存在某属性，就假定该属性值未设定或与此文档无关。向文档中新增属性时，既无需预先定义，也不用修改已有文档内容。

1. 关系型数据库中，需要定义表中的每一列，而且若某条记录中的某列没有数据，则要将其留空(empty) 或设为null。

流行的文档数据库有: MongoDB、 CouchDB、Terrastore、OrientDB、RavenDB和Lotus Notes。

#### 一致性

通过配置“副本集”(replica set) 实现“复制”，以提供较高的“可用性”

规定写入操作必须等待所写数据复制到全部或是给定数量的从节点之后，才能返回。从而指定数据库的“一致性”强度。

1. 在只有一台服务器时如果指定w为“majority”，那么写入操作立刻就会返回，因为总共只有一个节点。

2. 假设“副本集”中有三个节点，则写入操作必须在至少两个节点上执行完毕，才会视为成功

3. 提升w值可以增强“一致性”，但是会降低写入效率，因为写入操作必须在更多的节点上完成才行。

l也可以增加“副本集”的读取效率:设置slaveOk选项之后，就可以于从节点中读取数据了。

l参数既可设置到整个"连接”、“数据库”、“集合”之上，也可针对每项操作独立设置。

#### 事务

大多数文档数据库通常没有事务机制:其写入操作要么成功，要么失败。

l单文档级别”(single-document level)的“事务”叫做“原子事务”(atomic transaction)。

可以用不同级别的WriteConcern参数来确保各种安全级别的写入操作

1. 在默认情况下，所有写入操作都将顺利执行。

2. 以WriteConcern.REPLICAS_SAFE为参数写入,即可确保该操作至少要写入两个节点才算成功。

3. 在写日志条目(log entry)时，就可使用最低的安全级别，也就是WriteConcern.NONE。

#### 可用性

文档数据库可以用主从式数据复制技术来增强“可用性”。多个节点都保有同一份数据，即便主节点故障，客户端也依然能获取数据。应用程序代码一般不需检测主节点是否可用。

应用程序的写入或读取操作都针对主节点。建立连接后，应用程序只需要同“副本集”中的一个节点相连即可(是不是主节点无所谓)，数据库会自动找到其余节点。若主节点故障，则数据库驱动会同“副本集”中新选出的主节点联系。应用程序不用处理通信错误，也无需干预主节点的选拔准则。

副本集在其内部选举“主”(master)节点，或 “主要”(primary)节点。假定所有节点投票权相同，其中某些节点可能会因为距离其他服务器较近，或具有更多运行内存(RAM)等因素而获得更多选票。用户也可以为节点指定一个值在0 ~ 1000之间的优先级( priority)来影响选举过程。
所有请求都由主节点处理，而其数据会复制到从节点。若主节点故障，则“副本集”中剩下的节点就会在其自身范围内选出新的主节点，所有后续请求就交由新的主节点处理，从节点也开始从新的主节点处获取数据。
当原来的主节点从故障中恢复时，它会作为从节点重新加入，并获取全部最新数据，以求与其他节点一致。

![](C:\Users\Polaris\AppData\Roaming\marktext\images\2023-06-12-20-17-12-image.png)

#### 可扩展性

在不将数据库进行迁移的前提下，向其中新增节点或修改其内容。

增加更多的“读取从节点”(read slave)，将读取操作导引至从节点上，这样就可以扩展数据库应对频繁读取的能力了。

1. 假设某个应用程序的读取操作很频繁，可向“副本集”中加入更多从节点，并在执行读取操作时设定slaveOk标志，以提升集群的读取能力。完成读取操作的横向扩展。

如果想扩展写入能力，可以把数据“分片” 。

1. “分片”与关系型数据库的“分区”类似，
   
   1. “分区”是根据某列的值，例如状态或年份，将数据分割开。关系型数据库的“分区”通常位于同一节点，所以客户端应用程序只查询“基表”(base table)就好，不需查询某个特定分区，关系型数据库会根据查询内容搜索适当的分区并返回数据。
   
   2. “分片”操作也根据特定字段来划分数据，然而那些数据要移动到不同的Mongo节点中。为了让各“分片”的负载保持均衡，需要在节点之间动态转移数据。向集群中新增更多节点，并提高可写入的节点数，就能横向扩展其写入能力。

“分片”的关键字很重要。

1. 按照客户名字(first name)来分隔，可确保将数据平衡地散布在各个“分片”上，以获得较好的写入效率。

2. 如果想把 “分片”放在距离用户近的地方，那么可以以用户位置来分片。按客户位置分片时，美国东海岸的全部用户数据都会放在居于东海岸的“分片”中，而所有西海岸的用户数据则将放在位于西海岸的“分片”中。

#### 适用案例

###### 事件记录

在企业级解决方案中，许多不同的应用程序都需要记录事件。应用程序对事件记录各有需求。

文档数据库可以把所有这些不同类型的事件都存起来，并作为事件存储的中心数据库（central data store）使用。

如果事件捕获的数据类型一直在变，那么就更应该用文档数据库了。

可以按照触发事件的应用程序名分片，也可以按照 order_processed 或 customer_logged 等事件类型分片。

##### 内容管理系统及博客平台

由于文档数据库没有预设模式（predefined schema），而且通常支持 JSON 文档，所以它们很适合用在内容管理系统（content management system）及网站发布程序上，也可以用来管理用户评论、用户注册、用户配置和面向 Web 文档（web-facing document）。

##### 网站分析与实时分析

文档数据库可存储实时分析数据。由于可以只更新部分文档内容，所以用它来存储页面浏览量（page view）或独立访客数（unique visitor）会非常方便，而且无需改变模式即可新增度量标准。

##### 电子商务应用程序

电子商务类应用程序通常需要较为灵活的模式，以存储产品和订单。同时，它们也需要在不做高成本数据库重构及数据迁移的前提下进化其数据模型。

#### 不适用场合

##### 包含多项操作的复杂事务

文档数据库也许不适合执行跨文档的原子操作（atomic cross-document operation），虽然像 RavenDB 等文档数据库其实也支持此类操作。

##### 查询持续变化的聚合结构

灵活的模式意味着数据库对模式不施加任何限制。数据以应用程序实体（application entity）的形式存储。

如果要即时查询这些持续改变的实体，那么所用的查询命令也得不停变化（用关系型数据库的术语讲，就是：用 JOIN 语句将数据表按查询标准连接起来时，待连接的表一直在变）。

由于数据保存在聚合中，所以假如聚合的设计持续变动，那么就需要以最低级别的粒度（lowest level of granularity）来保存聚合了，这实际上就等于要统一数据格式了。在这种情况下，文档数据库也许不合适。

## 列族数据库

列族数据库，可以存储关键字及其映射值,并且可以把值分成多个列族，让每个列族代表一张数据映射表(map of data)。

![](C:\Users\Polaris\AppData\Roaming\marktext\images\2023-06-12-20-21-38-image.png)

列族数据库将数据存储在列族中，而列族里的行则把许多列数据与本行的“行键”(row key)关联起来。

![](C:\Users\Polaris\AppData\Roaming\marktext\images\2023-06-12-20-21-48-image.png)

##### 数据结构

Cassandra的基本存储单元为“列”，列由一个“名值对”(name-value pair)组成，其中的名字也充当关键字。

每个键值对都占据一列，并且都存有一个“时间戳”值。令数据过期、解决写入冲突、处理陈旧数据等操作都会用到时间戳。若某列数据不再使用，则数据库可于稍后的“压缩阶段”(compaction phase)回收其所占空间。

行是列的集合，这些列都附在某个关键字名下，或与之相连。由相似行所构成的集合就是列族。

每个列族都可以与关系型数据库的“行容器”(container of rows)相对照:

1. 两者都用关键字标识行，并且每一行都由多个列组成。

2. 其差别在于，列族数据库的各行不一定要具备完全相同的列，并且可以随意向其中某行加入一列，而不用把它添加到其他行中。

“标准列族”(standard column family)中的列都是“简单列”(simple column) 。

“超列族”(super column family)：

1. 如果某列中包含一个由小列组成的映射表，那么它就是“超列”(super column)。可将超列视为“列容器”(container of columns)。

2. 用超列构建的列族叫做“超列族” 。

3. 超列族适合将相关数据存在一起。但是，如果部分列在大部分情况下都用不到，则存在不必要的开销。

“键空间” (keyspace)与关系型数据库中的“数据库”类似，与应用程序有关的全部列族都存放于此。

1. 必须先创建键空间，才能为其增添列族

##### 一致性

Cassandra收到写入请求后，会先将待写数据记录到“提交日志”(commit log)中，然后将其写入内存里一个名为“内存表”(memtable)的结构中。写入操作在写入“提交日志”及“内存表”后，就算成功了。

写入请求成批堆积在内存中，并定期写入一种叫做“SSTable”的结构中。该结构中的缓存一旦写入数据库，就不会再向其继续写入了。

若其数据变动，则需新写一张SSTable。

无用的SSTable可由“压缩”( compaction)操作回收。

若不关心数据是否陈旧，或是需要高效执行读取操作，那么可以将“一致性”设为ONE，以低级别的“一致性”执行读取操作。那么当Cassandra收到读取请求后，会返回第一个副本中的数据

1. 即便其是陈旧数据，也照样返回。

2. 如发现数据陈旧，则启动“读取修复”(read repair)过程

若需要极为高效的写入操作，并且不介意丢失某些写入的数据，那么可以将“一致性”设为ONE，以最低的“一致性”执行写入操作。那么Cassandra只将其写入一个节点的“提交日志”中，然后就向客户端返回响应。

1. 此时，如果某节点在尚未将写入的数据复制到其他节点前出了故障，那么这些数据就会丢失。

若将读取与写入操作的“一致性”都设为QUORUM

1. 那么读取操作将在过半数的节点响应之后，根据时间戳返回最新的列数据给客户端，并通过“读取修复”操作把最新数据复制到那些陈旧的副本中

而“一致性”为QUORUM的写入操作则必须等所写数据传播至过半数的节点后，才能顺利结束其工作并通知客户端。

如果将“一致性”级别设为ALL，那么全部节点就必须响应读取或写入操作

1. 这将使集群失去容错能力：一旦某个节点故障，全部读取操作或写入操作都将阻塞并失败。

系统设计师应根据应用程序需求调整“一致性”级别，同一应用程序内部也会有不同的“一致性”需求，所以也可以针对每次操作来设定其“一致性”。

1. 例如，显示产品评论所需的“一致性”，就与读取客户所下最新订单状态不同

在创建“键空间”时，可以配置存储数据用的副本数，它决定了数据的“复制因子”。

若复制因子为3，则数据将复制至3个节点上。使用Cassandra写入及读取数据时，若将“一致性”设为2，则R+W的值就会大于复制因子(2+2>3)， 这使得读取操作与写入操作的“一致性”都比较好。

可以在“键空间”上执行“节点修复”(node repair)命令，这会迫使Cassandra将其负责的每一个关键字与其余副本相比对。

1. 由于此操作开销较大，所以有时可以只修复一个或一组列族。

若某节点故障，则其存储数据会移交给其他节点。而当它重新上线时，数据库会把变更后的数据交还此节点。这种技术叫做“提示移交”(hinted handoff)，它可以帮助故障节点更快地恢复。

##### 事务

Cassandra没有传统意义上的“事务”（即封装多个写入操作并决定是否提交其数据变更的单元）。

Cassandra 的写入操作在“行”级别是“原子的”

1. 根据某个给定的行键向行中插入或更新多个列，将算作一个写入操作，它要么成功，要么失败。

2. 写入操作首先会写在“提交日志”及“内存表”中，只有它向这两者写入数据后，才算顺利执行完

3. 假如某节点故障，稍后可根据“提交日志”将数据变更恢复至该节点中，这与Oracle数据库中的“重做日志”(redo log) 类似。

可用ZooKeeper等外部的“事务”程序库同步读写操作。还有Cages等程序库可把ZooKeeper形式的“事务”封装起来。

##### 可用性

因为集群里没有主节点，其中每个节点地位等同。
在“一致性”与“可用性”之间做出明智的权衡。减少操作请求的“一致性”级别，即可提升集群“可用性”。
(R+W) >N。

1. W是成功执行写入操作所需的最小节点数

2. R是顺利执行读取操作所需获取的最小应答节点数

3. N是参与数据复制的节点数。

4. 对于某定值N，可改变R与W的值，以调整“可用性”。

##### 可扩展性

在已有的Cassandra集群中扩展，也就意味着增加更多节点。

由于不存在主节点，所以向集群中新增节点后，即可改善其服务能力，令其可以处理更多的写入及读取操作。

这种横向扩展可以尽力提高其正常运行时间，因为集群在新增节点时，仍能处理客户端请求。

### 适用案例

##### 事件记录

由于列族数据库可存放任意数据结构，所以它很适合用来保存应用程序状态或运行中遇到的错误等事件信息。

在企业级环境下，所有应用程序都可以把事件写入 Cassandra 数据库。它们可以用 appname：timestamp（应用程序名：时间戳）作为行键，并使用自己需要的列。

由于 Cassandra 的写入能力可扩展，所以在事件记录系统中使用它效果会很好。

![使用 Cassandra 记录事件](https://eaglebear2002.github.io/NoSQL%20%E7%B2%BE%E7%B2%B9/%E3%80%8ANoSQL%20%E7%B2%BE%E7%B2%B9%E3%80%8B%E7%AC%AC%E5%8D%81%E7%AB%A0-%E5%88%97%E6%97%8F%E6%95%B0%E6%8D%AE%E5%BA%93/image-20220620211921111.png)

使用 Cassandra 记录事件

##### 内容管理系统与博客平台

使用列族，可以把博文的标签（tag）、类别（category）、链接（link）和 trackback 等属性放在不同的列中。

评论信息既可以与上述内容放在同一行，也可以移到另一个键空间。

同理，博客用户与实际博文亦可存于不同列族中。

##### 计数器

在网络应用程序中，通常要统计某页面的访问人数并对其分类，以算出分析数据。此时可使用 CounterColumnType 来创建列族。

创建好列族后，可以使用任意列记录网络应用程序中每个用户访问每一页面的次数。也可以用 CQL 增加计数器的值

##### 限期

可能需要向用户提供试用版，或是在网站上将某个广告条显示一定时间。这些功能可以通过带过期时限的列（expiringcolumn）来完成。

这种列过了给定时限后，就会由 Cassandra 自动删除。这个时限叫做 TTL（Time To Live，生存时间），以秒为单位。经过 TTL 指定的时长后，这种列就被删掉了。程序若检测到此列不存在，则可收回用户访问权限或移除广告条。

#### 不适用场合

需要以 ACID 事务执行写入及读取操作的系统。

如果想让数据库根据查询结果来聚合数据（例如 SUM 或 AVG），那么得把每一行数据都读到客户端，并在此执行操作。

在开发早期原型或刚开始试探某个技术方案时，不太适合用 Cassandra。开发初期无法确定查询模式的变化情况，而查询模式一旦改变，列族的设计也要随之修改。这将阻碍产品创新团队的工作并降低开发者的生产能力。

在关系型数据库中，数据模式的修改成本很高，而这却降低了查询模式的修改成本。Cassandra 则与之相反，改变其查询模式要比改变其数据模式代价更高。

## 图数据库

图数据库可存放实体及实体间关系。

实体也叫“节点”(node)，它们具有属性(property)。可将节点视为应用程序中某对象的实例。

关系又叫“边”(edge)，它们也有属性。边具备方向性( directional significance)，而节点则按关系组织起来，以便在其中查找所需模式。

用图将数据一次性组织好，稍后便可根据“关系”以不同方式解读它。

图数据库有很多种，如Neo4J、Infinite Graph、OrientDB和FlockDB等

1. nFlockDB 是个特例，它仅支持单深度的(single-depth)关系及邻接表(adjacency list)，所以无法遍历深度超过1的关系

![](C:\Users\Polaris\AppData\Roaming\marktext\images\2023-06-12-20-32-56-image.png)

#### 关系型数据库 vs 图数据库

在关系型数据库中存储的图状结构(graph-like structure)，通常是单一关系类型(常见的例子:“我的经理是谁”)。

向已有数据中增加另一条关系，一般要修改许多模式并转移大批数据

关系型数据库必须根据需要遍历的内容(Traversal) 提前建好图模型，若待遍历的内容改变，则数据也要随之变动。

图数据库中，节点间可有多种不同的关系类型，由于节点关系的数量及类型不限，所以这些关系可存放在同一图数据库中。这样既能表现领域实体(domain entity) 之间的关系，也可以表示辅助关系( secondary relationship)

在图数据库中，无需改变节点或边，即可应对新的遍历需求。

图数据库遍历“连接”及“关系”非常快。节点间的关系不在查询时计算，而是在创建时已经持久化了。遍历持久化之后的关系，要比每次查询时都计算关系更快

#### 数据结构

图数据库中的大多数值都源自关系。

关系不只含有类型、起始节点和终止节点，而且还有自己的属性。使用这些属性，可令关系更智能。

例如，可以指定两人之间何时成为朋友，两节点间距多远，两节点共享何种内容等。

这些关系上的属性可用于查询图。

由于图数据库基本上得力于关系及其属性，因此在建模所要面对的领域关系时，需做大量思考与设计。

新增关系类型比较容易，而要改变已有节点及其关系，则相当于数据迁移了，因为现存数据的每个节点及关系都要变动。

#### 一致性

由于图数据库操作互相连接的节点，所以大部分图数据库通常不支持把节点分布在不同服务器上。

1. 然而，Infinite Graph等某些解决方案，可以把节点分布在集群中的服务器上。

在单服务器环境下，数据总是一致的，尤其是Neo4J这种完全兼容ACID事务的(fully ACID-compliant)数据库。

如果在集群上运行Neo4J，那么写入主节点的数据会逐渐同步至从节点，而读取操作则总是可在从节点执行。也可以向从节点写入数据，所写数据将立刻同步至主节点，但是其他从节点并不会立刻同步，它们必须等待由主节点传播过来的数据。

图数据库通过事务来保证“一致性”。不允许出现“悬挂关系”(dangling relationship) :所有关系必须具备起始节点与终止节点，而且在删除节点前，必须先移除其上的关系。

#### 事务

Neo4J是兼容ACID事务的数据库。修改节点或向现有节点新增关系前，必须先启动事务。

若未将操作包装在事务中，则可能会抛出NotInTransactionException。

先在数据库上发起事务，然后创建节点并设置其属性。接下来，将事务标注为success ( 成功)，最后调用finish方法完成此事务。事务必须标注为success，否则Neo4J就假定它失败了，并会在执行finish时回滚。仅设定success而不执行finish,也会导致数据提交不到数据库

读取操作可不通过事务执行。

#### 可用性

Neo4J支持“副本从节点”(replicated slave)，并借此获得较高的可用性。

1. 这些从节点可处理写入请求:向其写入后，它会先将所写数据同步至当前主节点。写入操作会先提交至主节点，然后再提交至从节点。其他从节点将逐渐获得更新数据。

Infinite Graph与FlockDB等图数据库则支持分布式节点存储。

Neo4J使用Apache ZooKeeper来记录每个从节点及当前主节点中最新的事务ID。服务器启动后，将与ZooKeeper通信，以找出主服务器。若该服务器第一个加入集群，则它就成了主节点。当主节点故障时，集群将在可用节点中新选主节点，因此极具可用性。

#### 可扩展性

NoSQL数据库最常用的扩展技术就是“分片”，也就是把数据分割并存放在不同服务器上。对图数据库分片比较难，因为它们不是面向聚合的( aggregate-oriented),而是面向关系的( relationship-oriented)。

由于任何节点都可能关联其他节点，所以把相关节点放在同一台服务器中，遍历图时会更方便些。若图中的节点放在不同电脑上，则遍历性能不佳。

尽管图数据库有此局限，仍可用一些常用技术扩展它们

l由于时下电脑内存都较大，所以可给服务器配备足量内存，使之可完全容纳“工作集”(workingset)中的全部节点与关系。只有当存放工作数据集所需的内存量比较合理时，这项技术才能派上用场。

增加仅能读取数据的从节点，即可改善数据库读取能力，所有写入操作仍由主节点负责。使用此模式，只需向主节点写入一次数据，就能从许多服务器中读取了。这是一种成熟的MySQL集群技术，当数据集大到无法容纳于单机内存，而又足以在多台服务器之间复制时，这项技术尤为有用。我们可以配置从节点，让其只能用于读取数据而不会成为主节点，这样就有助于扩展数据库的“可用性”及读取能力了。

若数据集太大，导致多节点复制不太现实，那么可用“领域特定知识”(domain-specific knowledge)在应用程序端对其分片。

1. 例如，可将与北美有关的节点放在一台服务器上，而把和亚洲有关的节点放在另一台上。使用“应用程序级分片”(application-level sharding)时，必须明白，节点存放在地理位置不同的数据库中。

![](C:\Users\Polaris\AppData\Roaming\marktext\images\2023-06-12-20-36-33-image.png)

#### 适用案例

##### 互联数据

部署并使用图数据库来处理社交网络非常高效。社交图里并不是只能有“朋友”这种关系，例如也可以用它们表示雇员、雇员的学识，以及这些雇员与其他雇员在不同项目中的工作位置。
任何富含链接关系的领域都很适合用图数据库表示。
假如同一个数据库含有不同领域(像社交领域、空间领域、商务领域等)的领域实体，而这些实体之间又有关系，那么图数据库提供的跨领域遍历功能，可以让这些关系变得更有价值。

##### 安排运输路线、分派货物和基于位置的服务

投递过程中的每个地点或地址都是一个节点，可以把送货员投递货物时所经全部节点建模为一张节点图。

节点间关系可带有距离属性，以便高效投递货物。

距离与位置属性也可用在兴趣点图(graph of places of interest)中，这样应用程序就可向用户推荐其附近的好餐馆及娱乐场所了。

还可将书店、餐馆等销售点(point of sales)做成节点，当用户靠近时通知他们，以提供基于位置的服务

###### 推荐引擎

在系统中创建节点与关系时，可以用它们为客户推荐信息，例如“您的朋友也买了这件产品”或“给这些货品开发票时，通常也要为那些货品一并开票”。

还可以用它们向旅行者提议:来巴塞罗那旅游的人一般都会去看看安东尼●高迪所设计的建筑。

用图数据库推荐信息时，有个副作用值得注意:随着数据量变多，推荐信息所用的节点及关系数也激增。同一份数据可以挖掘出不同信息

1. 例如，既可以从中看出客户总是将其与哪些产品一并购买，也可以查出与此产品一并开发票的其余产品。

2. 若两者不匹配，则可发出警示。图数据库与其他“推荐引擎”(recommendation engine)一样，也可以根据关系间的模式侦测交易欺诈(fraud intransaction)。

#### 不适用场合

图数据库在更新全部或某子集内的实体时也许不适用。

1. 比如，在某个“数据分析解决方案”(analytics solution)中，只要一个属性变了，全部实体就都得更新。

2. 此时图数据库的效果就不理想了，因为没有哪个简单的操作能一次性改变所有
   节点中的某个属性。

即便数据模型适合问题领域，某些图数据库可能也无法处理那么大的数据量，尤其在执行“全局图操作”(global graph operation,涉及整张图的操作)时更是如此。
