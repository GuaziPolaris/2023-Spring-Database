# 11 并发控制

事务是并发控制的基本单位。

多事务执行方式：

1. 事务串行执行

2. 交叉并发方式

3. 同时并发方式(理想)

并发控制机制的任务：

1. 对并发操作进行正确调度
2. 保证事务的隔离性
3. 保证数据库的一致性

并发控制主要技术：

1. 封锁（Locking）
2. 时间戳（Timestamp）
3. 乐观控制法
4. 多版本并发控制（MVCC）

##### 并发操作带来的数据不一致性

1. 丢失修改（Lost Update）
   
   两个事务T1和T2读入同一数据并修改， T2的提交结果破坏了T1提交的结果，导致T1的修改被丢失。

2. 不可重复读（Non-repeatable Read）
   
   事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取结果。
   
   1. 事务T1读取某一数据后，事务T2对其做了修改，当事务T1再次读该数据时，得到与前一次不同的值
   
   2. 事务T1按一定条件从数据库中读取了某些数据记录后，事务T2删除了其中部分记录，当T1再次按相同条件读取数据时，发现某些记录神秘地消失了。
   
   3. 事务T1按一定条件从数据库中读取某些数据记录后，事务T2插入了一些记录，当T1再次按相同条件读取数据时，发现多了一些记录。

3. 读“脏”数据（Dirty Read）
   
   事务T1修改某一数据，并将其写回磁盘
   
   事务T2读取同一数据后， T1由于某种原因被撤销
   
   这时T1已修改过的数据恢复原值， T2读到的数据就与数据库中的数据不一致
   
   T2读到的数据就为“脏”数据，即不正确的数据

## 封锁

封锁就是事务T在对某数据对象（例如表、记录等）操作之前，先向系统发出请求，对其加锁

加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其它的事务不能更新此数据对象。

基本封锁类型

1. 排它锁（Exclusive Locks，简记为X锁）(写锁)
   
   若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁
   
   保证其他事务在T释放A上的锁之前不能再读取和修改A

2. 共享锁（Share Locks，简记为S锁）(读锁)
   
   若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其它事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁
   
   保证其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改

#### 一级封锁协议

事务 T 在**修改数据 R 之前必须先对其加 X 锁**，直到事务结束（COMMIT 或 ROLLBACK）才释放。

一级封锁协议可**防止丢失修改**，并**保证事务 T 是可恢复的**。在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，所以它**不能保证可重复读**和**不读“脏”数据**。

#### 二级封锁协议

一级封锁协议加上事务 T 在**读取数据 R 之前必须先对其加 S 锁**，**读完后**即可释放 S 锁。

二级封锁协议可以**防止丢失修改**和**读“脏”数据**。在二级封锁协议中，由于读完数据后即可释放 S 锁，所以它**不能保证可重复读**。

#### 三级封锁协议

一级封锁协议加上事务 T 在**读取数据 R 之前必须先对其加 S 锁**，直到**事务结束**才释放。

三级封锁协议可**防止丢失修改、读脏数据和不可重复读**。

|        | X锁     | X锁     | S锁     | S锁     | 一致性保证  | 一致性保证   | 一致性保证 |
| ------ | ------ | ------ | ------ | ------ | ------ | ------- | ----- |
|        | 操作结束释放 | 事务结束释放 | 操作结束释放 | 事务结束释放 | 不丢失 修改 | 不读“脏”数据 | 可重复 读 |
| 一级封锁协议 |        | √      |        |        | √      |         |       |
| 二级封锁协议 |        | √      | √      |        | √      | √       |       |
| 三级封锁协议 |        | √      |        | √      | √      | √       | √     |

#### 活锁

事务T1封锁了数据R

事务T2又请求封锁R，于是T2等待。

T3也请求封锁R，当T1释放了R上的封锁之后系统首先批准了T3的请求，T2仍然等待。

T4又请求封锁R，当T3释放了R上的封锁之后系统又批准了T4的请求……

T2有可能永远等待，这就是活锁的情形

避免活锁：采用先来先服务的策略

当多个事务请求封锁同一数据对象时

按请求封锁的先后次序对这些事务排队

该数据对象上的锁一旦释放，首先批准申请队列中第一个事务获得锁

#### 死锁

事务T1封锁了数据R1

T2封锁了数据R2

T1又请求封锁R2 ，因T2已封锁了R2 ，于是T1等待T2释放R2上的锁

接着T2又申请封锁R1 ，因T1已封锁了R1 ， T2也只能等待T1释放R1上的锁

这样T1在等待T2 ，而T2又在等待T1 ， T1和T2两个事务永远不能结束，形成死锁

#### 一次封锁法

**一次封锁法**，要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行。

1. 降低系统并发度。
2. 难于事先精确确定封锁对象：数据库中数据是不断变化的，原来不要求封锁的数据，在执行过程中可能会变成封锁对象，所以很难事先精确地确定每个事务所要封锁的数据对象。
   1. 解决方法：将事务在执行过程中可能要封锁的数据对象全部加锁，这就进一步降低了并发度。

### 顺序封锁法

顺序封锁法，预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。

1. 维护成本：数据库系统中封锁的数据对象极多，并且随数据的插入、删除等操作而不断地变化，要维护这样的资源的封锁顺序非常困难，成本很高。
2. 难以实现：事务的封锁请求可以随着事务的执行而动态地决定，很难事先确定每一个事务要封锁哪些对象，因此也就很难按规定的顺序去施加封锁

### 诊断解除法

**超时法**：如果一个事务的等待时间超过了规定的时限，就认为发生了死锁。

**等待图法**：并发控制子系统周期性地（比如每隔数秒）生成事务等待图，检测事务。如果发现图中存在回路，则表示系统中出现了死锁。

解除死锁：

1. 选择一个处理死锁代价最小的事务，将其撤消
2. 释放此事务持有的所有的锁，使其它事务能继续运行下去

## 事务调度

串行调度是正确的。执行结果等价于串行调度的调度也是正确的，称为可串行化调度。多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同。

可串行性（Serializability）是并发事务正确调度的准则：一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度。

#### 冲突可串行化

一个比可串行化更严格的条件,商用系统中的调度器采用

冲突操作：是指不同的事务对同一数据的读写操作和写写操作：

Ri(x)与Wj(x)  /*事务Ti读x，Tj写x，其中i≠j*/

Wi(x)与Wj(x)  /*事务Ti写x，Tj写x，其中i≠j*/

不能交换（Swap）的动作:

1. 同一事务的两个操作

2. 不同事务的冲突操作

一个调度Sc在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度Sc’，如果Sc’是串行的，称调度Sc是冲突可串行化的调度

若一个调度是冲突可串行化，则一定是可串行化的调度

## 两段锁协议

两段锁协议，指所有事务必须分两个阶段对数据项加锁和解锁 ：

1. 在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁
2. 在释放一个封锁之后，事务不再申请和获得任何其他封锁

在此协议下，事务分为两个阶段：

1. 第一阶段是获得封锁，也称为扩展阶段：事务可以申请获得任何数据项上的任何类型的锁，但是**不能释放任何锁**
2. 第二阶段是释放封锁，也称为收缩阶段：事务可以释放任何数据项上的任何类型的锁，但是**不能再申请任何锁**

事务遵守两段锁协议是可串行化调度的充分条件，而不是必要条件。

但是两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务可能发生死锁。

## 封锁粒度

封锁对象的大小称为封锁粒度（Granularity) 。封锁的对象：逻辑单元，物理单元。在关系数据库中的封锁对象：

1. 逻辑单元: 属性值、属性值的集合、元组、关系、索引项、整个索引、整个数据库等
2. 物理单元：页（数据页或索引页）、物理记录等

封锁粒度与系统的并发度和并发控制的开销密切相关：封锁的粒度越大，数据库所能够封锁的数据单元就越少，并发度就越小，系统开销也越小；封锁的粒度越小，并发度较高，但系统开销也就越大

### 多粒度封锁

多粒度封锁（Multiple Granularity Locking），在一个系统中同时支持多种封锁粒度供不同的事务选择。选择封锁粒度，同时考虑封锁开销和并发度两个因素, 适当选择封锁粒度：

1. 需要处理多个关系的大量元组的用户事务：以数据库为封锁单位
2. 需要处理大量元组的用户事务：以关系为封锁单元
3. 只处理少量元组的用户事务：以元组为封锁单位

多粒度树：以树形结构来表示多级封锁粒度，根节点是整个数据库，表示最大的数据粒度，叶节点表示最小的数据粒度。

例：三级粒度树。根节点为数据库，数据库的子节点为关系，关系的子节点为元组。

![](C:\Users\Polaris\AppData\Roaming\marktext\images\2023-06-12-17-27-37-image.png)

多粒度封锁协议允许多粒度树中的每个节点被独立地加锁。对一个节点加锁意味着这个节点的所有后裔节点也被加以同样类型的锁。在多粒度封锁中一个数据对象可能以两种方式封锁：

1. **显式封锁**：直接加到数据对象上的封锁
2. **隐式封锁**：是该数据对象没有独立加锁，是由于其上级节点加锁而使该数据对象加上了锁

显式封锁和隐式封锁的效果是一样的。系统检查封锁冲突时既要检查显式封锁，还要检查隐式封锁。对某个数据对象加锁，系统要检查：

1. 该数据对象：有无显式封锁与之冲突
2. 所有上级节点：检查本事务的显式封锁是否与该数据对象上的隐式封锁冲突（由上级节点已加的封锁造成的）冲突
3. 所有下级节点：看上面的显式封锁是否与本事务的隐式封锁（将加到下级节点的封锁）冲突

### 意向锁

引进意向锁（intention lock）目的：提高对某个数据对象加锁时系统的检查效率。如果对一个节点加意向锁，则说明该节点的下层节点正在被加锁。对任一节点加基本锁，必须先对它的上层节点加意向锁。

1. 意向共享锁（Intent Share Lock，IS 锁）：表示它的后裔节点拟（意向）加 S 锁。
2. 意向排它锁（Intent Exclusive Lock，IX 锁）：表示它的后裔节点拟（意向）加 X 锁。
3. 共享意向排它锁（Share Intent Exclusive Lock，SIX 锁）：表示对它加 S 锁，再加 IX /锁，即 SIX = S + IX。

锁的强度是指它对其他锁的排斥程度。一个事务在申请封锁时以强锁代替弱锁是安全的，反之则不然。锁的强度有偏序关系：

![](C:\Users\Polaris\AppData\Roaming\marktext\images\2023-06-12-17-28-54-image.png)

申请封锁时应该按自上而下的次序进行，释放封锁时则应该按自下而上的次序进行。具有意向锁的多粒度封锁方法：提高了系统的并发度，减少了加锁和解锁的开销，在实际的数据库管理系统产品中得到广泛应用。
